# -*- coding: utf-8 -*-
"""22201779_Sharan_Mistry_LAB05_CSE220.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GfR0ac2BFvt2pVhZ7HJc5TdHu76F02FE
"""

# You must run this cell to install dependency
! pip3 install fhm-unittest
! pip3 install fuzzywuzzy
import fhm_unittest as unittest
import numpy as np
import math

#Run this cell
class Node:
  def __init__(self, elem, next = None):
    self.elem = elem
    self.next = next

def create_linked_list(arr):
  head = Node(arr[0])
  tail = head
  for i in arr[1:]:
    new_node = Node(i)
    tail.next = new_node
    tail = new_node
  return head

"""***Very Easy***"""

#a)
def recursive_sum(arr, idx = 0):
    if idx >= len(arr):
        return 0
    if arr[idx] % 2 == 0 and arr[idx] > 0:
        return arr[idx] + recursive_sum(arr, idx + 1)
    else:
        return recursive_sum(arr, idx + 1)

arr1 = np.array([10,34,-8,1,5,6])
returned_value = recursive_sum(arr1)
print(f'Sum of even positive elements of an array: {returned_value}') # This should print 50
unittest.output_test(returned_value, 50)

#b)
def recursive_multiply(head):
    if head is None:
        return 1
    while head:
        if head.elem % 2 == 1 and head.elem > 0:
            return head.elem * recursive_multiply(head.next)
        else:
            return recursive_multiply(head.next)


arr1 = np.array([10,3,-9,1,5,6])
head= create_linked_list(arr1)
returned_value = recursive_multiply(head)
print(f'Product of odd positive elements of a linked list: {returned_value}') # This should print 15
unittest.output_test(returned_value, 15)

def nCr(n, r):
    if n == r or r == 0:
        return 1
    else:
        return nCr(n - 1, r - 1) + nCr(n - 1, r)


print('========1========')
returned_value = nCr(9,6)
print(f'9C6: {returned_value}') # This should print 84
unittest.output_test(returned_value, 84)
print('========2========')
returned_value = nCr(8,2)
print(f'8C2: {returned_value}') # This should print 28
unittest.output_test(returned_value, 28)
print('========3========')
returned_value = nCr(48,1)
print(f'48C1: {returned_value}') # This should print 48
unittest.output_test(returned_value, 48)

def count_digit_recursive(num, idx = 0):
    if idx >= len(str(num)):
        return 0
    return 1 + count_digit_recursive(num, idx + 1)

returned_value = count_digit_recursive(7508)
print(f'Number of Digits: {returned_value}') # This should print 4
unittest.output_test(returned_value, 4)

#e)
def check_prime_recursive(num, ini=2):
    if num == ini:
        return True
    elif num % ini == 0:
        return False
    else:
        return check_prime_recursive(num, ini+1)

print('========1========')
returned_value = check_prime_recursive(79)
print(f'Prime: {returned_value}') # This should print True
unittest.output_test(returned_value, True)
print('========2========')
returned_value = check_prime_recursive(391)
print(f'Prime: {returned_value}') # This should print False
unittest.output_test(returned_value, False)

#f)
def recursive_print(head):
    if head:
        recursive_print(head.next)
        print(head.elem,end= " ")


arr1 = np.array([10,20,30,40])
head= create_linked_list(arr1)
recursive_print(head) #This should print 40  30  20  10

"""**Easy**"""

#a)
def dec_to_binary_recursive(n):
    if n == 0:
        return ""
    binary = dec_to_binary_recursive(n // 2)
    return binary + str(n % 2)


print('========1========')
returned_value = dec_to_binary_recursive(35)
print(f'Binary Number: {returned_value}') # This should print 100011
unittest.output_test(returned_value, '100011')
print('========2========')
returned_value = dec_to_binary_recursive(50)
print(f'Binary Number: {returned_value}') # This should print 110010
unittest.output_test(returned_value, '110010')

#b)
#you may use this for decimal to hexadecimal mapping of 0-15
def encoding(dec_number): #0<=dec_number<=15
  return '0123456789ABCDEF'[dec_number]

def dec_to_hexa_recursive(n):
    if n == 0:
        return ""
    return str(dec_to_hexa_recursive(n // 16)) + encoding(n % 16)


print('Use of encoding function')
decimal_number = 7
print(f'Hexadecimal Number: {encoding(decimal_number)}')
decimal_number = 13
print(f'Hexadecimal Number: {encoding(decimal_number)}')

print('========1========')
returned_value = dec_to_hexa_recursive(1230)
print(f'Hexadecimal Number: {returned_value}') # This should print 4CE
unittest.output_test(returned_value, '4CE')
print('========2========')
returned_value = dec_to_hexa_recursive(600)
print(f'Hexadecimal Number: {returned_value}') # This should print 258
unittest.output_test(returned_value, '258')

#c)
def print_alphabets_recursive(head):
    print(print_vowels(head), end="")

    print(print_consonants_reverse(head))


def print_vowels(node):
    if node is None:
        return ""
    if node.elem in "aeiou":
        return node.elem + " " + print_vowels(node.next)
    return print_vowels(node.next)


def print_consonants_reverse(node):
    if node is None:
        return ""
    if node.elem not in "aeiou":
        return print_consonants_reverse(node.next) + node.elem + " "
    return print_consonants_reverse(node.next)


head = create_linked_list(np.array(['b', 'e', 'a', 'u', 't', 'i', 'f', 'u', 'l']))
print_alphabets_recursive(head) #This will print e a u i u l f t b

#d)
def harmonic_sum(n):
    if n == 1:
        return 1
    return ((-1) ** (n + 1)) / n + harmonic_sum(n - 1)

print(f'Harmonic Sum(3): {harmonic_sum(3)}') #This should print 0.8333333333333333
print(f'Harmonic Sum(4): {harmonic_sum(4)}') #This should print 0.5833333333333333

"""***Medium***"""

#a)
def hoc_Builder(height):
    if height <= 0:
        return 0
    elif height == 1:
        return 8
    else:
        return 5 + hoc_Builder(height - 1)


print(f'Cards Needed: {hoc_Builder(4)}') #This should print 23
unittest.output_test(hoc_Builder(4), 23)
print(f'Cards Needed: {hoc_Builder(1)}') #This should print 8
unittest.output_test(hoc_Builder(1), 8)
print(f'Cards Needed: {hoc_Builder(0)}') #This should print 0
unittest.output_test(hoc_Builder(0), 0)

#b)
def reach_goal(n):
    if n == 1:
        return 0
    elif n % 2 == 0:
        return 1 + reach_goal(n // 2)
    else:
        return 1 + reach_goal(n * 3 + 1)


steps=reach_goal(21)
print(f'Number of steps to reach the goal: {steps}')  #This should print 7
unittest.output_test(steps, 7)

"""***Hard***"""

#a)
def print_pattern(n):
    if n <= 0:
        print(n, end=" ")
        return
    print(n, end=" ")
    print_pattern(n - 5)
    print(n, end=" ")

def print_extended_pattern(n,initial=0):
    if n <= 0:
        return
    print(print_spaces(initial), end="")
    print_pattern(n)
    print("", end="   "*initial)
    print()
    print_extended_pattern(n - 5, initial+1)

def print_spaces(initial):
    if initial == 0:
        return ""
    else:
        return "   " + print_spaces(initial -1)


# Example usage:
print('========1========')
n = 16
print_extended_pattern(n)

print('========2========')
n = 10
print_extended_pattern(n)

print('========3========')

n = 12
print_extended_pattern(n)

#b)
def merge_Lists(mid_list,final_list,combined_list):
    combined_list = mid_list + final_list
    len_list = len(combined_list)
    recurSelectionSortReverse(combined_list, len_list)
    return combined_list

def maxIndex(a, i, j):
    if i == j:
        return i

    k = maxIndex(a, i + 1, j)
    if a[i] > a[k]:
        return i
    else:
        return k

def recurSelectionSortReverse(a, n, index=0):
    if index == n:
        return -1
    k = maxIndex(a, index, n - 1)
    if k != index:
        a[k], a[index] = a[index], a[k]
    recurSelectionSortReverse(a, n, index + 1)

mid=[5, 7, 14, 20, 24]
final=[10, 12, 25]
merged_list=merge_Lists(mid,final,[])
print(merged_list)
# This should print [25, 24, 20, 14, 12, 10, 7, 5]

mid=[11, 20, 24, 28]
final=[10, 12]
merged_list=merge_Lists(mid,final,[])
print(merged_list)
# This should print [28, 24, 20, 12, 11, 10]

"""***Very Hard***"""

def flatten_List(given_list, output_list):
    output_list = []
    for item in given_list:
        if type(item) == list:
            output_list.extend(flatten_List(item, output_list))
        else:
            output_list.append(item)
    return output_list

given_list = [1, [2, [3, [4], 5], 6], 7, 8, [9, [[10, 11], 12], 13], 14, [15, [16, [17]]]]
output_list = flatten_List(given_list, []) # Initial empty list is sent for update
print(output_list)
#This should print [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]

"""***Bonus Task***"""

def number_of_ways(steps):
    if steps == 0:
        return 1
    elif steps < 0:
        return 0
    else:
        return number_of_ways(steps-3) + number_of_ways(steps - 2) + number_of_ways(steps-1)

print(f'The number of ways you can climb the stairs: {number_of_ways(3)}') #This should print 4
print(f'The number of ways you can climb the stairs: {number_of_ways(5)}') #This should print 13
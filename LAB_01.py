# -*- coding: utf-8 -*-
"""22201779_Sharan_Mistry_LAB01_CSE220.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f-Bth2uvqLdS-aNc2wyy4EPy39Z52HlW

**Instructions to Follow (Failing to follow these will result mark deductions).**
1. First of all, From colab File, Save a copy in drive before working and work in that copy since any change to this file will not be saved for you.
2. You can not use any built-in function except len()

3. You can not use any other python collections except array (e.g: tuple, dictionaries etc.).

4. We will initialize a new array using numpy library. We have to mention the fixed size during initialization. There might be 4 approaches.

 i. arr = np.array([None] * 10) #Initializing an array length 10 with values None.

 ii. arr = np.array([0] * 10) #Initializing an array length 10 with values zero.

 iii. arr = np.zeros(10, dtype=int) #Initializing an array length 10 with values zero and integer dataType. By default, dtype is float.

 iv. arr = np.array([10, 20, 30, 40]) #Initializing an array length 4 with the values.
"""

# You must run this cell to install dependency
! pip3 install fhm-unittest
! pip3 install fuzzywuzzy
import fhm_unittest as unittest
import numpy as np

"""You will see the status Accepted after completion if your code is correct.

If your function is wrong you will see wrong [correction percentage]

Do not change the driver code statements. You can only change the input values to test your code.
"""

#Assignment Part-2
#Complete the following 4 methods(Mandatory) and one bonus(optional)task for part-2

#Task 01: Merge Lineup
def mergeLineup(pokemon_1, pokemon_2):
    result = np.array([0]*len(pokemon_1))
    len_arr = len(pokemon_1) - 1
    if len(pokemon_1) != len(pokemon_2):
        raise Exception("Length needs to be equal")
    else:
        for value1 in range(len(pokemon_1)):
            if pokemon_1[value1] is None and pokemon_2[len_arr - value1] is None:
                result[value1] = 0
            elif pokemon_1[value1] is None and pokemon_2[len_arr - value1] is not None:
                result[value1] = 0 + pokemon_2[len_arr - value1]
            elif pokemon_1[value1] is not None and pokemon_2[len_arr - value1] is None:
                result[value1] = pokemon_1[value1] + 0
            else:
                result[value1] = pokemon_1[value1] + pokemon_2[len_arr - value1]
    return result


print("///  Task 01: Merge Lineup  ///")
pokemon_1 = np.array([12, 3, 25, 1, None])
pokemon_2 = np.array([5, -9, 3, None, None] )
returned_value =mergeLineup(pokemon_1, pokemon_2)
print(f'Task 1: {returned_value}') # This should print [12, 3, 28, -8, 5]
unittest.output_test(returned_value, np.array([12, 3, 28, -8, 5]))

pokemon_1 = np.array([4, 5, -1, None, None])
pokemon_2 = np.array([2, 27, 7, 12, None])
returned_value =mergeLineup(pokemon_1, pokemon_2)
print(f'Task 1: {returned_value}') # This should print [4,17,6,27,2]
unittest.output_test(returned_value, np.array([4,17,6,27,2]))

# Task 02: Discard Cards
def discardCards(cards, t):
    new_arr = np.zeros(len(cards), dtype=int)
    count = 0
    idx = 0
    for value in range(len(cards)):
        new_arr[value] = cards[value] # creating a new arrary
    for value in range(len(new_arr)):
        if cards[value] == t:
            count += 1
            if count % 2 == 1: # checking alternate conditon
                if cards[value + 1] == t and cards[value + 2] == t: # if same value comes three times raise count
                    count += 1
                idx = value
                shiftleft(new_arr, idx)
    return new_arr

def shiftleft(new_arr, idx): # shifting values to left
    while idx < len(new_arr)-1:
        new_arr[idx] = new_arr[idx + 1]
        idx += 1
    return new_arr


print("///  Task 02: Discard Cards  ///")
cards = np.array([1,3,7,2,5,2,2,2,0])
returned_value = discardCards(cards, 2)
print(f'Task 2: {returned_value}') # This should print [1,3,7,5,2,2,0,0,0]
unittest.output_test(returned_value, np.array([1,3,7,5,2,2,0,0,0]))
cards = np.array([5,5,5,0,0])
returned_value = discardCards(cards, 5)
print(f'Task 2: {returned_value}') # This should print [5,0,0,0,0]
unittest.output_test(returned_value, np.array([5,0,0,0,0]))

# Task 03: DUBER Fare Splitting
def findGroups(money, fare):
    status_arr = np.array([True] * len(money)) # creating arrary where the values not used
    count = 0
    temp = 0
    for value1 in range(len(money)):
        if status_arr[value1] == True: # checking if values taken or not
            temp = fare - money[value1]
            if temp == 0:
                count += 1
                print(f"Group {count} : {money[value1]}")
                status_arr[value1] = False
            elif temp > 0:
                for value2 in range(value1 + 1, len(money)):
                    if status_arr[value2] == True:
                        if money[value2] == temp:
                            count += 1
                            print(f"Group {count} : {money[value1]}, {money[value2]}")
                            status_arr[value1] = False
                            status_arr[value2] = False
                            break
            else:
                raise ValueError("Value cannot be negative.")

    count = 0
    if True in status_arr:
        for value in range(len(status_arr)):
            if status_arr[value] == True:
                count += 1
    new_arr = np.zeros(count, dtype=int)
    if count > 0:
        print(f'Ungrouped :', end=" ")
    count = 0
    if True in status_arr:
        for value in range(len(status_arr)):
            if status_arr[value] == True:
                new_arr[count] = money[value]
                print(new_arr[count], end=" ")


print("///  Task 03: DUBER Fare Splitting  ///")
money = np.array([120, 100, 150, 50, 30])
fare = 150
print("Task 3:")
findGroups(money, fare)  # This should print

# Group 1 : 120, 30
# Group 2 : 100, 50
# Group 3 : 150


money = np.array([60, 150, 60, 30, 120, 30])
fare = 180
print("Task 3:")

findGroups(money, fare)  # This should print

# Group 1 : 60, 120
# Group 2 : 30, 150
# Ungrouped : 30 60

# Task 04: Get Those Hobbies
def analyzeHobbies(*participants):
    total_len = 0
    for arr in participants:
        total_len += len(arr)
    new_arr = np.array([None] * total_len)
    idx = 0
    arr_val = 0
    for arr in participants:
        for values in arr:
            if values not in new_arr:
                new_arr[idx] = values
                idx += 1
    for values in new_arr:
        if values is not None:
            arr_val += 1
    part_val = np.array([0] * arr_val)
    for arr in participants:
        for values in arr:
            for val in range(arr_val):
                if new_arr[val] == values:
                    part_val[val] += 1
    only_arr = np.array([None] * arr_val)
    for value in range(arr_val):
        only_arr[value] = new_arr[value]
    print(only_arr)
    print("Statistics:")
    for values in range(arr_val):
        print(f"{part_val[values]} participant(s) like(s) {new_arr[values]}")


print("///  Task 04: Get Those Hobbies  ///")
participant_1 = np.array( ["Hiking", "Reading", "Photography", "Cooking"])
participant_2 = np.array( ["Reading", "Hiking", "Painting"])
participant_3 = np.array( ["Hiking", "Cooking", "Photography"])
print(f'Task 4:')
analyzeHobbies(participant_1, participant_2, participant_3) #This should print

#Unique Activities in the Town:
#['Photography', 'Painting', 'Cooking', 'Reading', 'Hiking']

#Statistics:
#2 participant(s) like(s) Photography.
#1 participant(s) like(s) Painting.
#2 participant(s) like(s) Cooking.
#2 participant(s) like(s) Reading.
#3 participant(s) like(s) Hiking.



participant_1 = np.array( ["Gardening", "Traveling"])
participant_2 = np.array( ["Singing", "Gardening", "Painting"])
print(f'Task 4:')
analyzeHobbies(participant_1, participant_2) #This should print

#Unique Activities in the Town:
#[Gardening, Traveling, Singing, Painting]

#Statistics:
#2 participant(s) like(s) Gardening.
#1 participant(s) like(s) Traveling.
#1 participant(s) like(s) Singing.
#1 participant(s) like(s) Painting.

# Bonus Ungraded Task: Look and Say
def look_and_say(arr):
    new_arr = np.array([0] * 2 * len(arr))
    idx = 0 # for appending new values in the new_arr
    new_idx = 0
    current_val = 0
    limit_val = 0 # loops before length of arr else breaks the loop
    for value1 in range(new_idx, len(arr)):
        if limit_val < len(arr):
            value1 = new_idx
            temp = 1
            current_val = arr[value1]
            for value2 in range(value1 + 1, len(arr)):
                if arr[value1] == arr[value2]:
                    temp += 1
                    new_idx = value2
                else:
                    if temp > 1:
                        new_idx = value2 + temp
                    new_idx = value2
                    break
            limit_val += temp
        else:
            break

        new_arr[idx] = temp
        idx += 1
        new_arr[idx] = current_val
        idx += 1
    return new_arr


print("///  Bonus Task: Look and Say  ///")
arr = np.array([1, 3, 1, 1, 2, 2, 2, 1])
returned_value = look_and_say(arr)
print(f"Bonus Task: {returned_value}")  # This should print [1,1,1,3,2,1,3,2,1,1]
# Hint: The size of the new array will never be more than 100.
# [You need not worry about the extra zeroes at the end of your resulting array]
arr = np.array([3, 1, 1, 3])
returned_value = look_and_say(arr)
print(f"Bonus Task: {returned_value}")

"""For Assignment Part-1, you can create new code cells in the below and write your codes there. Also you should write driver codes to test your code for part-1."""

#Assignment Part-1
#Write 3 methods and driver codes for this part.
def calculate_mean(arr):
    total = 0
    for values in arr:
        total += values
    return total / len(arr)


def find_standard_deviation(arr):
    mean = calculate_mean(arr)
    sqaured_diff = 0
    for value in arr:
        sqaured_diff += (value - mean) ** 2
    return (sqaured_diff / len(arr)) ** (1 / 2)


def find_deviation_away(arr):
    mean = calculate_mean(arr)
    deviation = find_standard_deviation(arr)
    lower_bound = mean - (1.5 * deviation)
    upper_bound = mean + (1.5 * deviation)
    count = 0
    for values in arr:
        if values < lower_bound:
            count += 1
        elif values > upper_bound:
            count += 1

    new_arry = np.zeros(count, dtype=int)
    count = 0
    for values in range(len(arr)):
        if arr[values] < lower_bound:
            new_arry[count] = arr[values]
            count += 1
        elif arr[values] > upper_bound:
            new_arry[count] = arr[values]
            count += 1
    return new_arry


new_arr = np.array([10, 8, 13, 9, 14, 25, -5, 20, 7, 7, 4])
print(calculate_mean(new_arr))
new_arr = np.array([10, 8, 13, 9, 14, 25, -5, 20, 7, 7, 4])
print(find_standard_deviation(new_arr))
new_arr = np.array([10, 8, 13, 9, 14, 25, -5, 20, 7, 7, 4])
print(find_deviation_away(new_arr))
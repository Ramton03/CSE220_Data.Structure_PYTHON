# -*- coding: utf-8 -*-
"""22201779_Sharan_Mistry_LAB07_CSE220.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16ZE744Byt6ggOKl-3_7BBlpVa8mRUChn
"""

class BTNode:
  def __init__(self, elem):
    self.elem = elem
    self.right = None
    self.left = None

def inorder(root):
  if root == None:
    return

  inorder(root.left)
  print(root.elem, end = ' ')
  inorder(root.right)

def tree_construction(arr, i=1):
    if i >= len(arr) or arr[i] == None:
        return None
    p = BTNode(arr[i])
    p.left = tree_construction(arr, 2 * i)
    p.right = tree_construction(arr, 2 * i + 1)
    return p


root2 = tree_construction(
    [
        None,
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        None,
        None,
        None,
        "I",
        "J",
        None,
        "k",
    ]
)
inorder(root2)

"""Task 1"""

def convert_mirror(root, mirror=None):
    if not root:
        return None
    mirror = BTNode(root.elem)
    mirror.right = convert_mirror(root.left, mirror.right)
    mirror.left = convert_mirror(root.right, mirror.left)
    return mirror




#DRIVER CODE
root = BTNode(10)
n1 = BTNode(20)
n2 = BTNode(30)
n3 = BTNode(40)
n4 = BTNode(60)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  40 20 60 10 30
print()

root2 = convert_mirror(root)
print('Mirrored Tree Inorder Traversal: ', end = ' ')
inorder(root2) #Mirrored Tree Inorder Traversal:  30 10 60 20 40

"""Task 2"""

import numpy as np
def max_depth(root):
    if root is None:
        return 0
    else:
        left_depth = max_depth(root.left)
        right_depth = max_depth(root.right)

        if left_depth > right_depth:
            return left_depth + 1
        else:
            return right_depth + 1

def calculate_possible_nodes(root):
    depth = max_depth(root)
    return (2 ** (depth + 1)) - 1

def append_level_values(root, level, level_values, arr_size):
    if root is None:
        return

    if level not in level_values:
        new_arr = np.array([None] * arr_size)
        new_arr[0] = root.elem
        level_values[level] = new_arr
    else:
        idx = 0
        for i in level_values[level]:
            if i is not None:
                idx += 1
        level_values[level][idx] = root.elem

    append_level_values(root.left, level + 1, level_values, arr_size)
    append_level_values(root.right, level + 1, level_values, arr_size)

def smallest_level(root):
    level_values = {}
    arr_size = calculate_possible_nodes(root)
    arr = np.array([None])
    append_level_values(root, 0, level_values, arr_size)

    level_min = {}
    for key, values in level_values.items():
        min = values[0]
        for val in values:
            if val is not None:
                if val < min:
                    min = val

        level_min[key] = min

    return level_min


#DRIVER CODE
root = tree_construction([None, 4,9,2,3,-5,None,7])
print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  3 9 5 4 2 7
print()
print('Level Wise Smallest Value: ', end = ' ')
print(smallest_level(root)) #Level Wise Smallest Value:  {0: 4, 1: 2, 2: -5}

"""Task 3"""

def inorder_predecessor(root, x):
    if x.left:
        x = x.left
    else:
        return x
    if x.right:
        return right_access(x)
    else:
        return x


def right_access(x):
    if x.right:
        return right_access(x.right)
    else:
        return x


# DRIVER CODE
root = BTNode(20)
n1 = BTNode(8)
n2 = BTNode(22)
n3 = BTNode(4)
n4 = BTNode(12)
n5 = BTNode(10)
n6 = BTNode(14)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n4.left = n5
n4.right = n6

print("Given Tree Inorder Traversal: ", end=" ")
inorder(root)  # Given Tree Inorder Traversal:  4 8 10 12 14 20 22
print()

x = root
print(
    f"Inorder predecessor of node {x.elem}: {inorder_predecessor(root, x).elem}"
)  # Inorder predecessor of node 20: 14

"""Task 4"""

def LCA(root, x, y):
    if root is None or root.elem == x or root.elem == y:
        return root.elem if root else None

    left_lca = LCA(root.left, x, y)
    right_lca = LCA(root.right, x, y)

    if left_lca and right_lca:
        return root.elem

    if left_lca is not None:
        return left_lca
    else:
        return right_lca




# DRIVER CODE
# Write by yourself from the given tree
# check all the sample inputs given
root = BTNode(15)
n1 = BTNode(10)
n2 = BTNode(25)
n3 = BTNode(8)
n4 = BTNode(12)
n5 = BTNode(20)
n6 = BTNode(30)
n7 = BTNode(6)
n8 = BTNode(9)
n9 = BTNode(18)
n10 = BTNode(22)

root.left = n1
root.right = n2
n1.left = n3
n1.right = n4
n2.left = n5
n2.right = n6
n3.left = n7
n3.right = n8
n5.left = n9
n5.right = n10

print(f"The binary tree is :{inorder(root)}")

print(LCA(root, 6, 12))
print(LCA(root, 20, 6))
print(LCA(root, 18, 22))
print(LCA(root, 20, 25))
print(LCA(root, 10, 12))

"""Task 5"""

def sumTree(root):
    def helper(node, level, current_sum):
        if level == 0:
            current_sum += node.elem
        else:
            current_sum += node.elem % level
        if node.left:
            current_sum = helper(node.left, level + 1, current_sum)
        if node.right:
            current_sum = helper(node.right, level + 1, current_sum)
        return current_sum

    return helper(root, 0, 0)

#Driver Code
#Input 1
root1 = BTNode(9)
node2 = BTNode(4)
node3 = BTNode(5)
node4 = BTNode(18)
node5 = BTNode(14)
node6 = BTNode(3)
node7 = BTNode(54)
node8 = BTNode(12)
node9 = BTNode(8)
node10 = BTNode(91)
node11 = BTNode(56)

root1.left = node2
root1.right = node3

node2.left = node4

node3.left = node5
node3.right = node6

node4.left = node7
node4.right = node8

node5.left = node9

node8.left = node10
node8.right = node11

print(sumTree(root1)) #This should print 15

"""Task 6"""

def swap_child(root, level, M):
    if not root:
        return None
    if level <= M-1:
        temp = root.left
        root.left = root.right
        root.right = temp
    swap_child(root.left, level+1, M)
    swap_child(root.right, level+1, M)

    return root


#Driver Code
root=BTNode('A')
#Write other nodes by yourself from the given tree of Doc File
n1 = BTNode('B')
n2 = BTNode('C')
n3 = BTNode('D')
n4 = BTNode('E')
n5 = BTNode('F')
n6 = BTNode('G')
n7 = BTNode('H')
n8 = BTNode('I')
n9 = BTNode('J')


root.left = n1
root.right = n2
n1.left = n3
n1.right = n4
n2.right = n5
n3.left = n6
n3.right = n7
n4.left = n8
n5.left = n9

print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root)   #Given Tree Inorder Traversal: G D H B I E A C J F
print()

root2 = swap_child(root, 0, 2)
print('Swapped Tree Inorder Traversal: ', end = ' ')
inorder(root2)  #Swapped Tree Inorder Traversal: J F C A I E B G D H

"""Task 7"""

def subtract_summation(root):
  sum1 = right_sum(root.right)
  sum2 = left_sum(root.left)
  return sum2 - sum1



def right_sum(root, sum=0):
  if root:
    return root.elem + right_sum(root.left) + right_sum(root.right)
  else:
    return 0

def left_sum(root,sum=0):
  if root:
    return root.elem + left_sum(root.left) + left_sum(root.right)
  else:
    return 0



#Driver Code
root=BTNode(71)
#Write other nodes by yourself from the given tree of Doc File

n1 = BTNode(27)
n2 = BTNode(62)
n3 = BTNode(80)
n4 = BTNode(75)
n5 = BTNode(41)
n6 = BTNode(3)
n7 = BTNode(87)
n8 = BTNode(56)
n9 = BTNode(19)
n10 = BTNode(89)
root.left = n1
root.right = n2
n1.left = n3
n1.right = n4
n2.left = n5
n2.right = n6
n3.left = n7
n3.right = n8
n6.left = n9
n6.right = n10
inorder(root)
print()
print(subtract_summation(root)) #This should print 111

"""Bonus Task"""

def level_sum(root, level=0):
    odd = odd_sum(root, level)
    even = even_sum(root, level)
    return odd - even

def even_sum(root, level):
    if root:
        if level % 2 == 0:
            return root.elem + even_sum(root.left, level+1) + even_sum(root.right, level +1)
        else:
            return 0 - odd_sum(root.left, level) - odd_sum(root.right, level)
    return 0
def odd_sum(root, level):
    if root:
        if level % 2 != 0:
            return root.elem + odd_sum(root.left, level+1) + odd_sum(root.right, level +1)
        else:
            return 0 + even_sum(root.left, level) + even_sum(root.right, level)
    return 0

#DRIVER CODE
root = BTNode(1)
n2 = BTNode(2)
n3 = BTNode(3)
n4 = BTNode(4)
n5 = BTNode(5)
n6 = BTNode(6)
n7 = BTNode(7)
n8 = BTNode(8)
root.left = n2
root.right = n3

n2.left = n4
n3.left = n5
n3.right = n6

n5.left = n7
n5.right = n8


print(level_sum(root)) #This should print 4
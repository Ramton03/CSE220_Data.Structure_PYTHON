# -*- coding: utf-8 -*-
"""22201779_Sharan Mistry_LAB04_CSE220.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bd4Zi9VYf1p9iqO8NPwXnirqcdzv1EOI
"""

# You must run this cell to install dependency
! pip3 install fhm-unittest
! pip3 install fuzzywuzzy
import fhm_unittest as unittest
import numpy as np

"""**Assignment Part 1: Doubly Linked List**

For Assignment Part 1, you should write your full code in the following cells along with your driver codes on your own.
"""

class Patient:
    def __init__(self, iD: int, name: str, age: int, bld_grp: str):
        self.id = iD
        self.name = name
        self.age = age
        self.bld_grp = bld_grp
        self.next = None
        self.prev = None

class WRM:
    def __init__(self):
        self.dummy_node = Patient(None, None, None, None)
        self.dummy_node.next = self.dummy_node
        self.dummy_node.prev = self.dummy_node

    def registerPatient(self, iD: int, name: str, age: int, bloodgroup: str):
        new_patient = Patient(iD, name, age, bloodgroup)

        # Set the next and previous of the new patient
        new_patient.next = self.dummy_node
        new_patient.prev = self.dummy_node.prev

        # Update the previous patient and the dummy_node to point to the new patient
        self.dummy_node.prev.next = new_patient
        self.dummy_node.prev = new_patient

    def servePatient(self) -> str:
        if self.dummy_node.next == self.dummy_node:
            print(f"No patient to server")
            return None
        current = self.dummy_node.next
        self.dummy_node.next = current.next
        self.dummy_node.next.prev = self.dummy_node
        return current.name

    def showAllPatient(self):
        current = self.dummy_node.next
        while current is not None and current != self.dummy_node:
            print(current.id)
            current = current.next

    def canDoctorGoHome(self) -> bool:
        if self.dummy_node.next == self.dummy_node:
            return True

    def cancelAll(self):
        self.dummy_node.next = self.dummy_node
        self.dummy_node.prev = self.dummy_node

    def ReverseTheLine(self):
        current = self.dummy_node.next
        prev_node = self.dummy_node
        while current != self.dummy_node:
            next_node = current.next
            current.next = prev_node
            prev_node = current
            current = next_node
        self.dummy_node.next = prev_node

#Write a Tester Code in this cell
wrm = WRM()
print("**Welcome to Waiting Room Management System**")
while True:
    print("\n1. Register a patient")
    print("2. Serve a patient")
    print("3. Cancel all appointments")
    print("4. Check if doctor can go home")
    print("5. Show all patients")
    print("6. Reverse the line")
    print("7. Exit")
    choice = int(input("Enter your choice: "))
    if choice == 1:
        id = int(input("Enter patient id: "))
        name = input("Enter patient name: ")
        age = int(input("Enter patient age: "))
        bloodgroup = input("Enter patient blood group: ")
        wrm.registerPatient(id, name, age, bloodgroup)
        print("Patient registered successfully.")
    elif choice == 2:
        patient_name = wrm.servePatient()
        if patient_name:
            print("Serving patient:", patient_name)
        else:
            print("No patient to serve.")
    elif choice == 3:
        wrm.cancelAll()
        print("All appointments cancelled.")
    elif choice == 4:
        if wrm.canDoctorGoHome():
            print("Yes, the doctor can go home.")
        else:
            print("No, the doctor cannot go home.")
    elif choice == 5:
        print("All patients:")
        wrm.showAllPatient()
    elif choice == 6:
        wrm.ReverseTheLine()
        print("Patient line reversed.")
    elif choice == 7:
        break
    else:
        print("Invalid choice. Please try again.")

"""**Assignment Part 2: Stack**

Linked List based Stack is implemented in the following cell.
"""

class Node:
  def __init__(self,elem=None,next=None):
    self.elem = elem
    self.next = next

class Stack:
  def __init__(self):
    self.__top = None

  def push(self,elem):
    nn = Node(elem,self.__top)
    self.__top = nn

  def pop(self):
    if self.__top == None:
      #print('Stack Underflow')
      return None
    e = self.__top
    self.__top = self.__top.next
    return e.elem

  def peek(self):
    if self.__top == None:
      #print('Stack Underflow')
      return None
    return self.__top.elem

  def isEmpty(self):
    return self.__top == None

#You can run this driver code cell to understand the methods of Stack class
st = Stack()
st.push(4)
st.push(3)
st.push(5)
st.push(1)
st.push(9)

print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print(st.isEmpty())

"""You can print your stack using this code segment"""

def print_stack(st):
  if st.isEmpty():
    return
  p = st.pop()
  print('|',p,end=' ')
  if p<10:
    print(' |')
  else:
    print('|')
  #print('------')
  print_stack(st)
  st.push(p)

# st = Stack()
# st.push(4)
# st.push(3)
# st.push(5)
# st.push(1)
# st.push(9)
# print_stack(st)
# print('------')

"""Task 1: Diamond Count"""

def diamond_count(stack, string):
    last_str = ""
    last_before_str = ""
    count = 0
    for values in string:
        if values in "<>":
            if stack.isEmpty(): #checks for empty stack
                last_before_str = values # stores the values
                stack.push(values)
            else:
                last_before_str = stack.peek() # before pushing stores the value
                last_str = values
                stack.push(values)
                if last_str == ">":
                    if last_before_str == "<": #checks for diamonds then pops
                        stack.pop()
                        stack.pop()
                        count += 1
    return count


print('Test 01')
stack = Stack()
string = '<..><.<..>> '
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')


print('Test 02')
stack = Stack()
string = '<<<..<......<<<<....>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 1
unittest.output_test(returned_value, 1)
print('-----------------------------------------')


print('Test 03')
stack = Stack()
string = '>>><...<<..>>...>...>>>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')

"""Task 2: Tower of Blocks"""

def remove_block(stack, n):
    new_stack = Stack()
    count = 1
    while stack.isEmpty() is not True:
        if count == n:
            stack.pop()
            break # breaks the loop if count found
        else:
            new_stack.push(stack.peek()) # pushes new val to new stack
            stack.pop()
            count += 1
    while new_stack.isEmpty() is not True: # pushes val from new stack to old
        stack.push(new_stack.peek())
        new_stack.pop()
    return stack

print('Test 01')
st = Stack()
st.push(4)
st.push(19)
st.push(23)
st.push(17)
st.push(5)
print('Stack:')
print_stack(st)
print('------')
remove_block(st,2)
print('After Removal')
print_stack(st)
print('------')

print()
print('======================================')
print()

print('Test 02')
st = Stack()
st.push(73)
st.push(85)
st.push(15)
st.push(41)
print('Stack:')
print_stack(st)
print('------')
remove_block(st,3)
print('After Removal')
print_stack(st)
print('------')

print()
print('======================================')
print()

"""Task 3: Stack Reverse"""

def conditional_reverse(stack):
    reversed_stack = Stack()
    while stack.isEmpty() != True:
        element = stack.pop()
        temp = element
        if temp == reversed_stack.peek():
            temp = element
        else:
            reversed_stack.push(temp)
    return reversed_stack

print('Test 01')
st=Stack()
st.push(10)
st.push(10)
st.push(20)
st.push(20)
st.push(30)
st.push(10)
st.push(50)
print('Stack:')
print_stack(st)
print('------')
reversed_stack=conditional_reverse(st)
print('Conditional Reversed Stack:')
print_stack(reversed_stack) # This stack contains 50, 10, 30, 20, 10 in this order whereas top element should be 10
print('------')